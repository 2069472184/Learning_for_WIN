//https://www.acwing.com/problem/content/12/

/*
可以将dp看作一张有向图，最优的状态对应一条最优路径，路径上的每一个点都是一个中间状态，
在本题中我们用当前中间状态对应的物品编号来表示节点编号
*/

/*
如何处理“字典序最小”的要求？
1.解读:其实就是如果有靠前的物品能选就尽可能选靠前的物品
2.再来看看dp的运行规则，所谓动态规划，就是表明当前循环的最优解是不断更新的，
  也就是说，如果按照从小到大的编号顺序遍历物品，且 f[3][j] > f[3][j - v]，
  那么在 i = 4 时 f[i][j] = f[i - 1][j]，程序会在遍历到 4 号物品时更新状态表示，挤掉编号 i - 1 = 3 。
  这就会导致最佳方案物品的选取情况组合的字典序不是最小。
3.为了避免这种情况，就需要按照编号从大到小的顺序执行动态规划，如 i = 3 时 f[i][j] = f[i + 1][j]，反过来把 i + 1 = 4 号给更新了
4.在得到最优解 f[1][V] 之后，我们每次逆推一个物品：
    如果满足 f[i][j] = f[i - 1][j - v[i]] + w[i](不管是否 f[i - 1][j] 等不等于 f[i - 1][j - v[i]] + w[i]，只要是满足这个条件就输出)，
    则当前的 i 对应的状态正是最优路径上的点，且是由 i + 1 更新而来。
    所以我们输出的 i 值，它一定都是编号相对小的，当我们输出的所有编号都相对较小，那么它们组成的组合就是字典序最小的
*/

#include <iostream>

using namespace std;

const int N = 1010;

int n, V;
int v[N], w[N];
int f[N][N];

int main ()
{
    cin >> n >> V;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for (int i = n; i >= 1; i--)
        for (int j = 0; j <= V; j++)
        {
            f[i][j] = f[i + 1][j];
            if (j >= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);
        }
    
    int j = V;
    for (int i = 1; i <= n; i++)
        if (j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i]) 
        {
            cout << i << ' ';
            j -= v[i];
        }
    
    return 0;
}